-- CSC2021 Modelling Coursework Feb 2017
-- Complete the coursework by extending this file as specified
-- in the coursework.
-- Submit your modified copy of this file together with
-- output file generated by using the Run() command.
module Crossing
imports from IO all, from VDMUtil all
definitions

state Crossing of 
  leftBank : Place
  rightBank : Place
  boatPos: Bank
   -- Must ensure that there is no danger (Goat + Cabbage or Wolf + Goat) on either side of the river:
  inv mk_Crossing(leftBank, rightBank, boatPos) == Danger(leftBank) = false and Danger(rightBank) = false
  init cr == cr = mk_Crossing({<Goat>,<Wolf>,<Cabbage>,<Farmer>},{},<Left>)
  end 
  
  
types

Passenger = <Goat> | <Wolf> | <Cabbage> | <Farmer>;

Bank = <Left> | <Right>;

Place = set of Passenger;


functions

Danger: Place -> bool
Danger(bank) == 
	<Wolf> in set bank and <Goat> in set bank and <Farmer> not in set bank or  -- Danger if Wolf and Goat left alone
	<Goat> in set bank and <Cabbage> in set bank and <Farmer> not in set bank; -- or if Goat and Cabbage left alone

ValidCrossing: set of Passenger * Place -> bool
ValidCrossing(passengers, source) ==
	<Farmer> in set passengers and card passengers > 0 and card passengers < 3 and -- Ensure farmer is present and there is only 1 or 2 passengers.
	passengers subset source; -- Also ensure that the passengers are actually present at the source river bank.
	
operations

CrossRight: set of Passenger ==> ()  
CrossRight(passengers) == (
	leftBank := leftBank \ passengers;
	boatPos := <Right>;
	rightBank := rightBank union passengers;
)
-- Preconditions to ensure state invariant is not violated and ensures that boat is on the correct river bank.
pre Danger(leftBank \ passengers) = false and Danger(rightBank union passengers) = false and boatPos = <Left> and
ValidCrossing(passengers, leftBank); -- Also ensure farmer is present and we have 1 or 2 passengers.

CrossLeft: set of Passenger ==> ()  
CrossLeft(passengers) == (
	rightBank := rightBank \ passengers;
	boatPos := <Left>;
	leftBank := leftBank union passengers;
)
-- Preconditions to ensure state invariant is not violated and ensures that boat is on the correct river bank.
pre Danger(rightBank \ passengers) = false and Danger(leftBank union passengers) = false and boatPos = <Right> and
ValidCrossing(passengers, rightBank); -- Also ensure farmer is present and we have 1 or 2 passengers.

Run: () ==> ()
Run() ==
 ( 
  fopen();  -- reopen output file, overwriting current contents

--	fprintln("Failing solution start.");
--	fprintln("Left Bank: " ^ toString(leftBank));
--  fprintln("Right Bank: " ^ toString(rightBank));
--  fprintln("BoatPos: " ^ toString(boatPos));
--
--	CrossRight({<Farmer>, <Goat>});
--	fprintln("\nGoat + Farmer from Left to Right.");
--	fprintln("Left Bank: " ^ toString(leftBank));
--  fprintln("Right Bank: " ^ toString(rightBank));
--  fprintln("BoatPos: " ^ toString(boatPos)); 
--
--	CrossLeft({<Farmer>, <Wolf>});
--	fprintln("\nFarmer + Wolf from Right to Left.");
--	fprintln("Left Bank: " ^ toString(leftBank));
--  fprintln("Right Bank: " ^ toString(rightBank));
--  fprintln("BoatPos: " ^ toString(boatPos));

  fprintln("Start.");
  fprintln("Left Bank: " ^ toString(leftBank));
  fprintln("Right Bank: " ^ toString(rightBank));
  fprintln("BoatPos: " ^ toString(boatPos));
  
  CrossRight({<Farmer>, <Goat>});
  fprintln("\nGoat + Farmer from Left to Right.");
  fprintln("Left Bank: " ^ toString(leftBank));
  fprintln("Right Bank: " ^ toString(rightBank));
  fprintln("BoatPos: " ^ toString(boatPos));
  
  CrossLeft({<Farmer>});
  fprintln("\nFarmer from Right to Left.");
  fprintln("Left Bank: " ^ toString(leftBank));
  fprintln("Right Bank: " ^ toString(rightBank));
  fprintln("BoatPos: " ^ toString(boatPos));
  
  CrossRight({<Farmer>, <Cabbage>});
  fprintln("\nCabbage + Farmer from Left to Right.");
  fprintln("Left Bank: " ^ toString(leftBank));
  fprintln("Right Bank: " ^ toString(rightBank));
  fprintln("BoatPos: " ^ toString(boatPos));
  
  CrossLeft({<Farmer>, <Goat>});
  fprintln("\nGoat + Farmer from Right to Left.");
  fprintln("Left Bank: " ^ toString(leftBank));
  fprintln("Right Bank: " ^ toString(rightBank));
  fprintln("BoatPos: " ^ toString(boatPos));
  
  CrossRight({<Farmer>, <Wolf>});
  fprintln("\nWolf + Farmer from Left to Right.");
  fprintln("Left Bank: " ^ toString(leftBank));
  fprintln("Right Bank: " ^ toString(rightBank));
  fprintln("BoatPos: " ^ toString(boatPos));
  
  CrossLeft({<Farmer>});
  fprintln("\nFarmer from Right to Left.");
  fprintln("Left Bank: " ^ toString(leftBank));
  fprintln("Right Bank: " ^ toString(rightBank));
  fprintln("BoatPos: " ^ toString(boatPos));
  
  CrossRight({<Farmer>, <Goat>});
  fprintln("\nGoat + Farmer from Left to Right.");
  fprintln("Left Bank: " ^ toString(leftBank));
  fprintln("Right Bank: " ^ toString(rightBank));
  fprintln("BoatPos: " ^ toString(boatPos));
  
  fprintln("\nFinished.");

  -- complete this operation by adding a sequence of steps to solve the puzzle
  -- solution can be found at
  -- https://illuminations.nctm.org/BrainTeasers.aspx?id=4992  
 );
    
    
    
-- Output functions - should not need to edit below this line
 values
 outfile: seq of char = "crossing-run.txt";
 
 operations
 fopen: () ==> ()
 fopen() ==
  (dcl OK: bool;
   OK := IO`fecho(outfile, "", <start>);
   );
   
 fprint: seq of char ==> ()
 fprint(string) == 
  (dcl OK: bool;
   OK := IO`fecho(outfile, string, <append>););
 
 fprintln:  seq of char ==> ()
 fprintln(string) == fprint (string ^ "\n");
 
 fprintState:() ==> ()
 fprintState() == ( 
   fprintln("Crossing state:\n============");
   fprintln(toString(Crossing));
   );
 
   
types  -- build a union type for all types we might want to print
basic = int | nat | nat1 | real | bool | char | token;
defined = Passenger | Bank | Place | Crossing;
collection = set of basic | set of defined | seq of basic | seq of defined;
alltypes = basic | defined | collection

functions
 toString: alltypes -> seq of char
 toString(x) == 
   VDMUtil`val2seq_of_char[alltypes](x);  
   
end Crossing
